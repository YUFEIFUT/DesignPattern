# 责任链模式实现解析

## 一、模式结构与核心类

本包实现了典型的责任链（Chain of Responsibility）模式，主要用于审批流程的解耦。核心类如下：

### 1. `Approver`（抽象处理者）
- 定义了下一个处理者 `Approver approver`。
- 持有处理者姓名 `String name`。
- 提供 `setApprover(Approver approver)` 方法设置链条下一个处理者。
- 抽象方法 `processRequest(PurchaseRequest purchaseRequest)`，由子类实现具体处理逻辑。

### 2. `PurchaseRequest`（请求对象）
- 包含请求类型 `type`、金额 `price`、编号 `id`。
- 通过构造方法初始化，提供 getter 方法。

### 3. 具体处理者
- `DepartmentApprover`、`CollegeApprover`、`ViceSchoolMasterApprover`、`SchoolMasterApprover` 均继承自 `Approver`。
- 每个处理者根据金额区间判断是否有权限处理请求，若能处理则输出信息，否则将请求传递给下一个处理者。

## 二、责任链的组装与使用

在 `Client` 中：
- 创建各级审批人实例。
- 通过 `setApprover` 方法将各审批人串联成一个环形链表（最后一个指向第一个）。
- 发起请求时，从任意一个处理者开始，链式传递直到被处理。

## 三、实现逻辑梳理

1. **请求发起**：
   - 创建 `PurchaseRequest`，如：`new PurchaseRequest(1, 31000, 1)`。
2. **链条组装**：
   - 依次调用 `setApprover`，形成环形链。
3. **请求处理**：
   - 调用 `processRequest`，每个处理者判断是否能处理，不能则传递给下一个。
   - 例如：
     - `DepartmentApprover` 处理金额 ≤ 5000
     - `CollegeApprover` 处理 5000 < 金额 ≤ 10000
     - `ViceSchoolMasterApprover` 处理 10000 < 金额 ≤ 30000
     - `SchoolMasterApprover` 处理金额 > 30000

## 四、注意事项

1. **环形链的风险**
   - 若没有终止条件，环形链可能导致死循环。实际开发中应增加"已处理"标记或最大传递次数。
2. **职责分明**
   - 每个处理者只关心自己能否处理，不能处理则无条件传递，符合开闭原则。
3. **灵活扩展**
   - 新增审批人只需继承 `Approver` 并插入链条，无需修改其他类。
4. **请求入口灵活**
   - 可以从链上任意节点发起请求。

## 五、示意代码片段

```java
// 组装链条
Approver a = new DepartmentApprover("A");
Approver b = new CollegeApprover("B");
Approver c = new ViceSchoolMasterApprover("C");
Approver d = new SchoolMasterApprover("D");
a.setApprover(b);
b.setApprover(c);
c.setApprover(d);
d.setApprover(a); // 环形

// 发起请求
PurchaseRequest req = new PurchaseRequest(1, 31000, 1);
a.processRequest(req);
```

## 六、总结

本实现通过责任链模式有效解耦了请求与处理者，便于审批流程的灵活扩展和维护。但实际使用时需注意环形链的终止条件，避免死循环。 